#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

FILE *infile;

enum token
{
    t_constant,
    t_name,
    t_auto,
    t_extrn,
    t_case,
    t_if,
    t_while,
    t_switch,
    t_goto,
    t_return,
    t_unEquals,
    t_unMinus,
    t_unNot,
    t_binOr,
    t_binAnd,
    t_binEquals,
    t_binNotEquals,
    t_binLThan,
    t_binLThanE,
    t_binGThan,
    t_binGThanE,
    t_binLShift,
    t_binRShift,
    t_binMinus,
    t_binPlus,
    t_binMod,
    t_binMultiply,
    t_binDivide,
    t_singleQuote,
    t_doubleQuote,
    t_lCurly,
    t_rCurly,
    t_lParen,
    t_rParen,
    t_lSquare,
    t_rSquare,
    t_comma,
    t_semicolon,
    t_colon,
    t_ternary
};

char *token_names[] = {
    "Constant",
    "Name",
    "auto",
    "extrn",
    "case",
    "if",
    "while",
    "switch",
    "goto",
    "return",
    "U Equals",
    "U Minus",
    "U Not",
    "-",
    "B And",
    "B Equals",
    "B Not Equals",
    "B LThan",
    "B LThanE",
    "B GThan",
    "B GThan",
    "B LShift",
    "B RShift",
    "B Minus",
    "B Plus",
    "B Modulo",
    "B Multiply",
    "B Divide",
    "Single Quote",
    "Double Quote",
    "Left Curly",
    "Right Curly",
    "Left Paren",
    "Right Paren",
    "Left Bracket",
    "Right Bracket",
    "Comma",
    "Semicolon",
    "Colon",
    "Ternary"};

enum production
{
    p_program,
    p_definition,
    p_name,
    p_constant,
    p_ival,
    p_statement,
    p_auto,
    p_semicolon,
    p_colon,
    p_rvalue,
    p_lvalue,
    p_assign,
    p_unary,
    p_binary,
    p_alpha,
    p_digit,
    p_alphadigit,
    p_lparen,
    p_rparen,
    p_lcurly,
    p_rcurly,
    p_lsquare,
    p_rsquare,
    p_extrn,
    p_case,
    p_if,
    p_while,
    p_switch,
    p_goto,
    p_return,
    p_ternary,
    p_ampersand,
    /*
    * everything from here down is generated by me
    * mostly to do with arbitrary length productions    * 
    */
    p_statementlist,    // 0 or more statements
    p_definitionlist,   // 1 or more definitions (program can't be empty)
    p_ivallist,         // 1 or more ivals, separated by commas
    p_optionalivallist, // 0 or 1 ival lists
    p_optionalconstant, // 0 or 1 constants
    p_namelist,         // 1 or more names, separated by commas
    p_optionalnamelist, // 0 or 1 name lists
    p_optionalrvalue    // 0 or 1 rvalues

};

char *production_names[] = {
    "Program",
    "Definition",
    "Name",
    "Constant",
    "Ival",
    "Statement",
    "Auto",
    ";",
    ":",
    "rvalue",
    "lvalue",
    "=",
    "unary op",
    "binary op",
    "alpha",
    "digit",
    "alphadigit",
    "(",
    ")",
    "{",
    "}",
    "[",
    "]",
    "extrn",
    "case",
    "if",
    "while",
    "switch",
    "goto",
    "return",
    "?",
    "&",
    /*
    * everything from here down is generated by me
    * mostly to do with arbitrary length productions    * 
    */
    "statement list",
    "definition List",
    "ival List",
    "Optional ival List",
    "Optional Constant",
    "name List",
    "Optional name List",
    "Optional rvalue"

};

#define BUF_SIZE 16
char buffer[BUF_SIZE];
int buflen;
enum token currentToken;
char inChar;

/*
void parseStackPush(struct parseStack *it, enum production theProduction)
{
    printf("Pushing production of type [%s]\n", production_names[theProduction]);
    struct PSNode *newNode = malloc(sizeof(struct PSNode));
    newNode->productionType = theProduction;
    if (it->size == 0)
    {
        it->bottom = newNode;
        it->top = newNode;
    }
    else
    {
        it->top->next = newNode;
        newNode->prev = it->top;
        it->top = newNode;
    }
    it->size++;
}

enum production parseStackPop(struct parseStack *it)
{
    if (it->size == 0)
    {
        printf("Error - tried to pop from empty stack\n");
        exit(1);
    }
    struct PSNode *poppedNode;
    if (it->size == 1)
    {
        poppedNode = it->top;
        it->top = NULL;
        it->bottom = NULL;
    }
    else
    {
        poppedNode = it->top;
        it->top = it->top->prev;
    }
    it->size--;
    enum production retType = poppedNode->productionType;
    free(poppedNode);
    return retType;
}
*/
struct astNode
{
    char *value;
    enum token type;
    struct astNode *child;
    struct astNode *sibling;
};

struct astNode *newastNode(enum token t, char *newdata)
{
    struct astNode *retNode = malloc(sizeof(struct astNode));
    retNode->child = NULL;
    retNode->sibling = NULL;
    retNode->type = t;
    retNode->value = malloc(buflen);
    strcpy(retNode->value, newdata);
    return retNode;
}

void astNode_insertSibling(struct astNode *it, struct astNode *newSibling)
{
    struct astNode *runner = it;
    while (runner->sibling != NULL)
    {
        runner = runner->sibling;
    }

    runner->sibling = newSibling;
}

void astNode_insertChild(struct astNode *it, struct astNode *newChild)
{

    if (it->child == NULL)
    {
        it->child = newChild;
    }
    else
    {
        astNode_insertSibling(it->child, newChild);
    }
}

void printAST(struct astNode *it, int depth)
{
    if (it->child != NULL)
    {
        printAST(it->child, depth + 1);
    }
    for (int i = 0; i < depth; i++)
    {
        printf("\t");
    }
    printf("%s \n", it->value);
    if (it->sibling != NULL)
    {
        printAST(it->sibling, depth);
    }
}

/*
struct ASTStackNode
{
    struct astNode *data;
    struct ASTStackNode *next;
    struct ASTStackNode *prev;
};

struct ASTStack
{
    struct ASTStackNode *bottom;
    struct ASTStackNode *top;
    int size;
};

void ASTStackPush(enum token t, char *image)
{
    struct astNode *newNode = malloc(sizeof(struct astNode));
    newNode->value = malloc(strlen(image));
    strcpy(newNode->value, image);
    newNode->type = t;

    struct ASTStackNode *newStackNode = malloc(sizeof(struct ASTStackNode));
    newStackNode->data = newNode;

    if (astStack->size == 0)
    {
        astStack->bottom = newStackNode;
        astStack->top = newStackNode;
    }
    else
    {
        astStack->top->next = newStackNode;
        newStackNode->prev = astStack->top;
        astStack->top = newStackNode;
    }
    astStack->size++;
}

struct astNode *ASTStackPop()
{
    if (astStack->size == 0)
    {
        printf("popped from empty stack\n");
        exit(1);
    }
    struct astNode *poppedData;
    struct ASTStackNode *poppedNode;
    if (astStack->size == 1)
    {
        poppedNode = astStack->top;
        astStack->top = NULL;
        astStack->bottom = NULL;
    }
    else
    {
        poppedNode = astStack->top;
        astStack->top = astStack->top->prev;
    }
    astStack->size--;
    poppedData = poppedNode->data;printAST(
    free(poppedNode);
    return poppedData;
}
*/

char lookahead_dumb()
{
    long offset = ftell(infile);
    char returnChar = fgetc(infile);
    fseek(infile, offset, SEEK_SET);
    return returnChar;
}

void trimWhitespace()
{
    int whitespace;
    switch (lookahead_dumb())
    {
    case ' ':
    case '\n':
    case '\t':
        whitespace = 1;
        break;
    case '#':
        // recursively handling comments is easy
        // will this come at a cost later?
        while (lookahead_dumb() != '\n')
        {
            fgetc(infile);
        }
        fgetc(infile);
        trimWhitespace();
    default:
        whitespace = 0;
        break;
    }
    while (whitespace)
    {
        fgetc(infile);
        switch (lookahead_dumb())
        {
        case -1:
        case '\0':
        case ' ':
        case '\n':
        case '\t':
            break;
        case '#':
            trimWhitespace();
        default:
            whitespace = 0;
            break;
        }
    }
}

char lookahead()
{
    for (int i = 0; i < 0xffffff; i++)
    {
    }
    trimWhitespace();
    char r = lookahead_dumb();
    printf("Looking ahead to [%c]\n", r);
    return r;
}

void scan()
{
    buflen = 0;
    // check if we're looking for whitespace - are we?
    trimWhitespace();
    int scanning;
    if (infile != EOF)
    {
        scanning = 1;
    }
    else
    {
        scanning = 0;
    }
    while (scanning)
    {
        inChar = fgetc(infile);
        buffer[buflen++] = inChar;
        buffer[buflen] = '\0';
        if (!strcmp(buffer, "if"))
        {
            currentToken = t_if;
            return;
        }
        else if (!strcmp(buffer, "auto"))
        {
            currentToken = t_auto;
            return;
        }
        else if (!strcmp(buffer, "extrn"))
        {
            currentToken = t_extrn;
            return;
        }
        else if (!strcmp(buffer, "case"))
        {
            currentToken = t_case;
            return;
        }
        else if (!strcmp(buffer, "if"))
        {
            currentToken = t_if;
            return;
        }
        else if (!strcmp(buffer, "while"))
        {
            currentToken = t_while;
            return;
        }
        else if (!strcmp(buffer, "switch"))
        {
            currentToken = t_switch;
            return;
        }
        else if (!strcmp(buffer, "goto"))
        {
            currentToken = t_goto;
            return;
        }
        else if (!strcmp(buffer, "return"))
        {
            currentToken = t_return;
            return;
        }

        switch (inChar)
        {
        case ';':
            currentToken = t_semicolon;
            scanning = 0;
            break;
        case ':':
            currentToken = t_colon;
            scanning = 0;
            break;
        case ',':
            currentToken = t_comma;
            scanning = 0;
            break;
        case '(':
            currentToken = t_lParen;
            scanning = 0;
            break;
        case ')':
            currentToken = t_rParen;
            scanning = 0;
            break;
        case '{':
            currentToken = t_lCurly;
            scanning = 0;
            break;
        case '}':
            currentToken = t_rCurly;
            scanning = 0;
            break;
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case '0':
            if (buflen == 1)
            {
                currentToken = t_constant;
            }
            else if (currentToken != t_name)
            {
                printf("Error - unexpected char [%c] in token [%s] \n", inChar, buffer);
            }
            break;
        case '=':
            switch (currentToken)
            {
            case t_binEquals:
                currentToken = t_binEquals;
                scanning = 0;
                break;
            case t_unNot:
                currentToken = t_binNotEquals;
                scanning = 0;
                break;
            case t_binLThan:
                currentToken = t_binLThanE;
                scanning = 0;
                break;
            case t_binGThan:
                currentToken = t_binGThanE;
                scanning = 0;
                break;

            default:
                if (lookahead() != '=')
                {
                    if (buflen > 2)
                    {
                        printf("ERROR: More than 2 [=] in a row!\n");
                        exit(1);
                        //error();
                    }
                    else if (buflen == 2)
                    {
                        currentToken = t_binEquals;
                        scanning = 0;
                    }
                    else
                    {
                        currentToken = t_unEquals;
                        scanning = 0;
                    }
                }
                break;
            }
            break;
        case '|':
            currentToken = t_binOr;
            scanning = 0;
            break;

        case '&':
            currentToken = t_binAnd;
            scanning = 0;
            break;

        case '!':
            currentToken = t_unNot;
            if (lookahead() != '=') // only thing that can extend ! in a token is an =
            {
                scanning = 0;
            }
            break;

        case '<':
            if (buflen == 1) // only 1 '<' so far
            {
                currentToken = t_binLThan;
                if (lookahead() != '=' && lookahead() != '<') // only thing that can extend < in a token is an = or <
                {
                    scanning = 0;
                }
            }
            else // only way to have a < as the second char is to have lShift token
            {
                currentToken = t_binLShift;
                scanning = 0;
            }
            break;

        case '>':
            if (buflen == 1)
            {
                currentToken = t_binGThan;
                if (lookahead() != '=' && lookahead() != '>') // only thing that can extend > in a token is an = or >
                {
                    scanning = 0;
                }
            }
            else // only way to have a > as the second char is to have rShift token
            {
                currentToken = t_binRShift;
                scanning = 0;
            }
            break;

        case '-':
            currentToken = t_binMinus;
            scanning = 0;
            break;

        case '+':
            currentToken = t_binPlus;
            scanning = 0;
            break;

        case '%':
            currentToken = t_binMod;
            scanning = 0;
            break;

        case '*':
            currentToken = t_binMultiply;
            scanning = 0;
            break;

        case '/':
            currentToken = t_binDivide;
            scanning = 0;
            break;

        case -1:
            //case '\0':
            //case ' ':
            //case '\n':
            //case '\t':
            buflen--;
            buffer[buflen] = '\0';
            // don't include whitespace in the buffer
            scanning = 0;
            break;

        default:
            currentToken = t_name;
            break;
        }

        // if there's a paren or bracket coming up
        // terminate the scanning, our token is done
        //printf("LOOKAHEAD IS %c : %d\n", lookahead());
        switch (lookahead_dumb())
        {
        case '(':
        case ')':
        case '{':
        case '}':
        case '&':
        case ' ':
        case '\t':
        case '\n':
        case '\0':
        case ',':
        case ':':
        case ';':
            scanning = 0;
            break;
        }
    }
}

char *lookaheadToken() // look ahead at the entire next token, populate the buffer
{
    trimWhitespace();
    for (int i = 0; i < 0xffffff; i++)
    {
    }
    long offset = ftell(infile);
    scan();                          // simply use the scan function to get exactly what the next token is, no fuss
    fseek(infile, offset, SEEK_SET); // then seek backwards as if we never scanned
    printf("Looking ahead to token [%s] [%s]\n", buffer, token_names[currentToken]);
    return buffer;
}

char *lookaheadToken2() // look ahead at the entire 2nd next token, populate the buffer
{
    trimWhitespace();

    long offset = ftell(infile);
    scan(); // simply use the scan function to get exactly what the next token is, no fuss
    scan();
    fseek(infile, offset, SEEK_SET); // then seek backwards as if we never scanned
    return buffer;
}

struct astNode *match(enum token t)
{

    scan();
    if (currentToken == t)
    {
        printf("Matched token [%s] with image of [%s]\n", token_names[t], buffer);
        struct astNode *retNode = newastNode(t, buffer);
        return retNode;
    }
    else
    {
        printf("Error matching - expected token [%s], got [%s] with image of [%s] instead!\n", token_names[t], token_names[currentToken], buffer);
        return NULL;
    }
}

void consume(enum token t)
{
    scan();
    if (currentToken == t)
    {
        printf("Consumed token [%s] with image of [%s]\n", token_names[t], buffer);
    }
    else
    {
        printf("Error consuming - expected token [%s], got [%s] with image of [%s] instead!\n", token_names[t], token_names[currentToken], buffer);
    }
}

/*
void stackParse()
{
    upcomingStack = malloc(sizeof(struct parseStack));
    inProgressStack = malloc(sizeof(struct parseStack));
    astStack = malloc(sizeof(struct ASTStack));
    printf("Entered stackparse routine\n");
    parseStackPush(upcomingStack, p_program);
    while (upcomingStack->size > 0)
    {
        // spin so this goes at a sane pace
        // there *will* be accidental loops, need to read the output
        for (int i = 0; i < 0xffffff; i++)
        {
        }
        enum production currentProduction = parseStackPop(upcomingStack);
        printf("Parsing production [%s]\n", production_names[currentProduction]);
        switch (currentProduction)
        {
        case p_program:
            parseStackPush(upcomingStack, p_definitionlist);
            // need to include EOF token or not?
            break;

        case p_definitionlist:
            if (lookahead() == ',')
            {
                consume(t_comma);
            }
            if (isalpha(lookahead())) // we have at least 1 more definition to go
            {
                parseStackPush(upcomingStack, p_definitionlist);
                parseStackPush(upcomingStack, p_definition);
            }
            // if we have a definition list and don't see something in FIRST(name) (alpha char) we are done
            break;

        case p_definition:
            if (isalpha(lookahead()))
            {
                match(t_name);
                char l = lookahead();
                if (isalpha(l) || isdigit(l) || l == '[')
                {
                    // name {[{constant01}]}01 {ival {, ival}0}01;
                    parseStackPush(upcomingStack, p_semicolon);
                    parseStackPush(upcomingStack, p_optionalivallist);
                    parseStackPush(upcomingStack, p_ival);
                    if (l == '[')
                    {
                        parseStackPush(upcomingStack, p_rsquare);
                        parseStackPush(upcomingStack, p_optionalconstant);
                        parseStackPush(upcomingStack, p_lsquare);
                    }
                }
                else if (l == '(')
                {
                    // name ( {name {, name}0}01 ) statement
                    parseStackPush(upcomingStack, p_statement);
                    parseStackPush(upcomingStack, p_rparen);
                    parseStackPush(upcomingStack, p_optionalnamelist);
                    parseStackPush(upcomingStack, p_lparen);
                }
                else if (l == ';') // just a name declaration
                {
                    parseStackPush(upcomingStack, p_semicolon);
                }
                else
                {
                    printf("Error - expected '[', '(', or ival after name in definition\n");
                    error();
                }
            }
            else
            {
                printf("Error parsing definition - expected name\n");
                error();
            }
            break;

        case p_ival:
            if (isalpha(lookahead()))
            {
                parseStackPush(upcomingStack, p_name);
            }
            else if (isdigit(lookahead()))
            {
                parseStackPush(upcomingStack, p_constant);
            }
            else
            {
                printf("Error parsing ival - expected constant or name!\n");
                error();
            }
            break;

        case p_statementlist:
            // naive?
            // sure it'll allow unwanted chars in, but the errors will be at match time so better verbosity?
            // is there any other disadvantage to blindly accepting anything here?
            if (lookahead() != '}')
            {
                parseStackPush(upcomingStack, p_statementlist);
                parseStackPush(upcomingStack, p_statement);
            }
            break;

        case p_statement:
            char *nextToken = lookaheadToken();
            if (!strcmp(nextToken, "auto")) // auto name {constant}01 {, name {constant}01}0 ;  statement
            {
                // {, name {constant}01}0 PART IS UNHANDLED
                parseStackPush(upcomingStack, p_statement);
                parseStackPush(upcomingStack, p_semicolon);
                parseStackPush(upcomingStack, p_optionalconstant);
                parseStackPush(upcomingStack, p_name);
                parseStackPush(upcomingStack, p_auto);
            }
            else if (!strcmp(nextToken, "extrn")) // extrn name {, name}0 ; statement
            {
                parseStackPush(upcomingStack, p_statement);
                parseStackPush(upcomingStack, p_semicolon);
                parseStackPush(upcomingStack, p_optionalnamelist);
                parseStackPush(upcomingStack, p_name);
                parseStackPush(upcomingStack, p_extrn);
            }
            else if (!strcmp(nextToken, "case"))
            {
                parseStackPush(upcomingStack, p_statement);
                parseStackPush(upcomingStack, p_colon);
                parseStackPush(upcomingStack, p_name);
                parseStackPush(upcomingStack, p_case);
            }
            else if (!strcmp(nextToken, "if")) // if ( rvalue ) statement {else statement}01
            {
                parseStackPush(upcomingStack, p_statement);
                parseStackPush(upcomingStack, p_rparen);
                parseStackPush(upcomingStack, p_rvalue);
                parseStackPush(upcomingStack, p_lparen);
                parseStackPush(upcomingStack, p_if);
            }
            else if (!strcmp(nextToken, "while")) // whit_autoe ( rvalue ) statement
            {
                parseStackPush(upcomingStack, p_statement);
                parseStackPush(upcomingStack, p_rparen);
                parseStackPush(upcomingStack, p_rvalue);
                parseStackPush(upcomingStack, p_lparen);
                parseStackPush(upcomingStack, p_while);
            }
            else if (!strcmp(nextToken, "switch"))
            {
                parseStackPush(upcomingStack, p_statement);
                parseStackPush(upcomingStack, p_rvalue);
                parseStackPush(upcomingStack, p_switch);
            }
            else if (!strcmp(nextToken, "goto"))
            {

                parseStackPush(upcomingStack, p_semicolon);
                parseStackPush(upcomingStack, p_rvalue);
                parseStackPush(upcomingStack, p_goto);
            }
            else if (!strcmp(nextToken, "return"))
            {
                parseStackPush(upcomingStack, p_optionalrvalue);
                parseStackPush(upcomingStack, p_return);
            }
            else
            {
                /* name : statement
                 * what even is this production intended to mean?
                if (isalpha(lookahead()))
                {
                    printf("SWITCH CASE\n");
                    parseStackPush(upcomingStack, p_statement);
                    parseStackPush(upcomingStack, p_colon);
                    parseStackPush(upcomingStack, p_name);
                }
                else 
                
                if (lookahead() == '{')
                {
                    // { {statement}0 }
                    // NOTE - current production DOES NOT support optional statements ({}), there MUST be something in between the curly braces
                    parseStackPush(upcomingStack, p_rcurly);
                    parseStackPush(upcomingStack, p_statementlist);
                    parseStackPush(upcomingStack, p_lcurly);
                }
                else
                {
                    parseStackPush(upcomingStack, p_optionalrvalue);
                }
            }
            break;

        case p_auto:
            match(t_auto);
            break;

        case p_extrn:
            match(t_extrn);
            break;

        case p_case:
            match(t_case);
            break;

        case p_if:
            match(t_if);
            break;

        case p_while:
            match(t_while);
            break;

        case p_switch:
            match(t_switch);
            break;

        case p_goto:
            match(t_goto);
            break;

        case p_return:
            match(t_return);
            break;

        case p_name:
            match(t_name);
            break;

        case p_lparen:
            match(t_lParen);
            break;

        case p_rparen:
            match(t_rParen);
            break;

        case p_lcurly:
            match(t_lCurly);
            break;

        case p_rcurly:
            match(t_rCurly);
            break;

        case p_namelist:
            if (lookahead() == ',')
            {
                consume(t_comma);
            }
            if (isalpha(lookahead()))
            {
                parseStackPush(upcomingStack, p_namelist);
                parseStackPush(upcomingStack, p_name);
            }
            break;
        case p_optionalnamelist:
            if (isalpha(lookahead()))
            {
                parseStackPush(upcomingStack, p_namelist);
            }
            else
            {
                printf("Optional name List not present\n");
            }
            break;
        case p_optionalivallist:
            if (isalpha(lookahead()) || isdigit(lookahead()))
            {
                parseStackPush(upcomingStack, p_ivallist);
            }
            else
            {
                printf("Optional ival List not present\n");
            }
            break;
        case p_optionalrvalue:
            // get both the next and second next token
            lookaheadToken();

            switch (currentToken)
            {
            case t_lParen: // ( rvalue )
                parseStackPush(upcomingStack, p_rparen);
                parseStackPush(upcomingStack, p_rvalue);
                parseStackPush(upcomingStack, p_lparen);
                break;
            case t_name: // production starts with lvalue
                matchlvalue();
                if (lookahead() == '=')
                {
                    parseStackPush(upcomingStack, p_rvalue);
                    parseStackPush(upcomingStack, p_assign);
                } // NEED ELSE CASE FOR inc-dec
                break;
            case t_binMultiply:                // NEED TO ADD rvalue[rvalue] SUPPORT FOR ARRAYS
                matchlvalue();
                if (lookahead() == '=')
                {
                    parseStackPush(upcomingStack, p_rvalue);
                    parseStackPush(upcomingStack, p_assign);
                } // NEED ELSE CASE FOR inc-dec
                break;

            case t_constant:
                parseStackPush(upcomingStack, p_constant);
                break;
            // need support for inc-dec
            case t_binAnd:
                parseStackPush(upcomingStack, p_ampersand);
                parseStackPush(upcomingStack, p_lvalue);
                break;
            default:
                switch (secondToken)
                {
                case t_binEquals:
                case t_binOr:
                case t_binAnd:
                case t_binNotEquals:
                case t_binLThan:
                case t_binLThanE:
                case t_binGThan:
                case t_binGThanE:
                case t_binRShift:
                case t_binLShift:
                case t_binMinus:
                case t_binPlus:
                case t_binMod:
                case t_binMultiply:
                case t_binDivide: // rvalue binary rvalue
                    parseStackPush(upcomingStack, p_rvalue);
                    parseStackPush(upcomingStack, p_binary);
                    parseStackPush(upcomingStack, p_rvalue);
                    break;

                case t_unEquals: // lvalue assign rvalue
                    printf("YEAH YEAH\n");
                    parseStackPush(upcomingStack, p_rvalue);
                    parseStackPush(upcomingStack, p_assign);
                    parseStackPush(upcomingStack, p_lvalue);
                    break;

                case '?':
                    parseStackPush(upcomingStack, p_rvalue);
                    parseStackPush(upcomingStack, p_colon);
                    parseStackPush(upcomingStack, p_rvalue);
                    parseStackPush(upcomingStack, p_ternary);
                    parseStackPush(upcomingStack, p_rvalue);
                }
            }

            /*
            switch (l)
            {
            case '(': // ( rvalue )
                parseStackPush(upcomingStack, p_rparen);
                parseStackPush(upcomingStack, p_rvalue);
                parseStackPush(upcomingStack, p_lparen);
                break;
            case '=': // unary rvalue
            case '-':
            case '!':
                parseStackPush(upcomingStack, p_rvalue);
                parseStackPush(upcomingStack, p_unary);
                break;

            case '&':
                parseStackPush(upcomingStack, p_rvalue);
                parseStackPush(upcomingStack, p_ampersand);
                break;

            }
            break;
            

        case p_optionalconstant:
            if (isdigit(lookahead()))
            {
                parseStackPush(upcomingStack, p_constant);
            }
            else
            {
                printf("Optional Constant not present\n");
            }
            break;
        case p_semicolon:
            match(t_semicolon);
        }

        /*
        // keep track of what's being worked on so we can shift and reduce
        parseStackPush(inProgressStack, currentProduction);
        switch (inProgressStack->bottom->productionType)
        {
            // case for all production types
            // whenever we see something *not* in that production
            // decide somehow to reduce and how to build the tree
        default:
            break;
        }
        
    }
}*/

// productions explicitly enumerated by the grammar in the handbook
struct astNode *parseProgram();
struct astNode *parseDefinition();
struct astNode *parseIval();
struct astNode *parseStatement();
struct astNode *parseRvalue();
struct astNode *parseAssign();
struct astNode *parseIncDec();
struct astNode *parseUnary();
struct astNode *parseBinary();
struct astNode *parseLvalue();
struct astNode *parseConstant();
struct astNode *parseName();
struct astNode *parseAlphaDigit();
// generated productions to make parsing easier
struct astNode *parseNameList();
struct astNode *parseStatementList();

struct astNode *parseProgram()
{
    struct astNode *definition = NULL;
    while (lookahead() != EOF)
    {
        if (definition == NULL)
        {
            definition = parseDefinition();
        }
        else
        {
            astNode_insertSibling(definition, parseDefinition());
        }
    }
    printf("done parsing program\n");
    return definition;
}

struct astNode *parseDefinition()
{
    printf("Parsing definition\n");
    struct astNode *definition;
    if (isalpha(lookahead()))
    {
        definition = parseName();
        if (lookahead() == '[')
        {
            consume(t_lSquare);
            if (isdigit(lookahead()))
            {
                astNode_insertChild(definition, parseConstant());
            }
            consume(t_rSquare);
            consume(t_semicolon);
            // no handling for {ival {, ival}0}01
        }
        else if (lookahead() == '(')
        {
            consume(t_lParen);
            astNode_insertChild(definition, parseNameList());
            consume(t_rParen);
            astNode_insertChild(definition, parseStatement());
        }
        else
        {
            printf("yowch\n");
        }
    }
    return definition;
}

struct astNode *parseIval()
{
    printf("Parsing ival\n");
    return NULL;
}

struct astNode *parseStatement()
{
    struct astNode *statement;
    printf("Parsing statement\n");
    lookaheadToken();
    switch (currentToken)
    {
    case t_auto:
        statement = match(t_auto);
        astNode_insertChild(statement, parseNameList());
        consume(t_semicolon);
        astNode_insertSibling(statement, parseStatement());
        break;

    case t_extrn:
        statement = match(t_extrn);
        astNode_insertChild(statement, parseNameList());
        consume(t_semicolon);
        astNode_insertSibling(statement, parseStatement());
        break;

    case t_name:
        lookaheadToken2();
        switch (currentToken)
        {
        case t_colon:
            statement = match(t_name);
            consume(t_colon);
            astNode_insertChild(statement, parseStatement());
            break;

        default:
            statement = parseRvalue();
            break;
        }
        //statement = match(t_name);
        //consume(t_colon);
        //astNode_insertChild(statement, parseStatement());
        break;

    case t_case:
        statement = match(t_case);
        astNode_insertChild(statement, parseConstant());
        consume(t_colon);
        astNode_insertChild(statement, parseStatement());
        break;

    case t_lCurly:
        consume(t_lCurly);
        statement = parseStatement();
        consume(t_rCurly);
        break;

    case t_if:
        statement = match(t_if);
        consume(t_lParen);
        astNode_insertChild(statement, parseRvalue());
        consume(t_rParen);
        astNode_insertChild(statement, parseStatement());
        break;

    case t_while:
        statement = match(t_while);
        consume(t_lParen);
        astNode_insertChild(statement, parseRvalue());
        consume(t_rParen);
        astNode_insertChild(statement, parseStatement());
        break;

    case t_switch:
        statement = match(t_switch);
        astNode_insertChild(statement, parseRvalue());
        astNode_insertChild(statement, parseStatement());
        break;

    case t_goto:
        statement = match(t_goto);
        astNode_insertChild(statement, parseRvalue());
        consume(t_semicolon);
        break;

    case t_return:
        statement = match(t_return);
        astNode_insertChild(statement, parseRvalue());
        consume(t_semicolon);
        break;

    default: // DOESN'T COVER {rvalue}01
        statement = parseRvalue();
        printf("nothin there\n");
    }

    printf("done parsing statement\n");
    return statement;
}

struct astNode *parseStatementList()
{
    lookaheadToken();
}

struct astNode *parseRvalue()
{
    struct astNode *rValue;
    struct astNode *rValue2;
    printf("parsing rvalue\n");
    lookaheadToken();
    switch (currentToken)
    {
    case t_lParen:
        consume(t_lParen);
        rValue = parseRvalue();
        consume(t_rParen);
        break;

    case t_constant:
        rValue = match(t_constant);
        break;

    // unary rvalue
    case t_unMinus:
        rValue = match(t_unMinus);
        astNode_insertChild(rValue, parseRvalue());
        break;

    case t_unNot:
        rValue = match(t_unNot);
        astNode_insertChild(rValue, parseRvalue());
        break;

    case t_binAnd:
        rValue = match(t_binAnd);
        astNode_insertChild(rValue, parseLvalue());
        break;

    case t_name:
    case t_binMultiply: // lvalue
                        // NOTE rvalue[rvalue] NOT INCUDED YET
        rValue2 = parseLvalue();
        lookaheadToken();
        switch (currentToken)
        {
        case t_binEquals:
            rValue = match(t_unEquals);
            astNode_insertChild(rValue, rValue2);
            astNode_insertChild(rValue, parseRvalue());
            break;
            // NEED TO ADD CASES FOR INC-DEC
        }
        break;

    default:
        rValue2 = parseRvalue();
        lookaheadToken();
        switch (currentToken)
        {
        case t_binOr:
        case t_binAnd:
        case t_binEquals:
        case t_binNotEquals:
        case t_binLThan:
        case t_binLThanE:
        case t_binGThan:
        case t_binGThanE:
        case t_binLShift:
        case t_binRShift:
        case t_binMinus:
        case t_binPlus:
        case t_binMod:
        case t_binMultiply:
        case t_binDivide: // rvalue binary rvalue
            rValue = match(currentToken);
            astNode_insertChild(rValue, rValue2);
            astNode_insertChild(rValue, parseRvalue());
            break;

        case t_ternary: // rvalue ? rvalue : rvalue
            rValue = match(t_ternary);
            astNode_insertChild(rValue, rValue2);
            astNode_insertChild(rValue, parseRvalue());
            consume(t_colon);
            astNode_insertChild(rValue, parseRvalue());
            break;
        default:
            printf("Error parsing rvalue [%s]\n", buffer);
            rValue = NULL;
        }
        /*if (isalpha(lookahead())) // all lvalue cases
        {
            struct astNode *lValue = parseLvalue();
            if (lookahead() == '=') // lvalue assign rvalue
            {
                rValue = match(t_unEquals);
                astNode_insertChild(rValue, lValue);
                astnode_insertChild(rValue, parseRvalue());
            }
            else // lvalue
            {
                rValue = lValue;
            }
        }
        else
        {
            // sad
            rValue = NULL;
        }*/
    }
    return rValue;
}

struct astNode *parseAssign()
{
    return NULL;
}

struct astNode *parseIncDec()
{
    return NULL;
}

struct astNode *parseUnary()
{
    return NULL;
}

struct astNode *parseBinary()
{
    return NULL;
}

struct astNode *parseLvalue()
{
    struct astNode *lValue;
    if (isalpha(lookahead()))
    {
        lValue = match(t_name);
    }
    else if (lookahead() == '*')
    {
        lValue = match(t_binMultiply);
        astNode_insertChild(lValue, parseRvalue());
    }
    return lValue;
}

struct astNode *parseConstant()
{
    printf("Parsing constant\n");
    return match(t_constant);
}

struct astNode *parseName()
{
    printf("Parsing name\n");
    return match(t_name);
}

struct astNode *parseAlphaDigit()
{
    return NULL;
}

struct astNode *parseNameList()
{
    printf("Parsing name list\n");
    struct astNode *nameList = match(t_name);
    while (1)
    {
        if (lookahead() == ',')
        {
            consume(t_comma);
            astNode_insertSibling(nameList, match(t_name));
        }
        else
        {
            break;
        }
    }
    return nameList;
}

int main(int argc, char **argv)
{
    printf("%s\n", argv[1]);
    infile = fopen(argv[1], "rb");
    struct astNode *program = parseProgram();
    printAST(program, 0);

    /*while (lookahead() != EOF)
    {
        scan();
        printf("Scanned %s with token of %s\n", &buffer, token_names[currentToken]);
    }*/
    printf("done printing\n");
}