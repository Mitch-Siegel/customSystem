#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

FILE *infile;

enum token
{
    t_constant,
    t_name,
    t_auto,
    t_if,
    t_unEquals,
    t_unMinus,
    t_unNot,
    t_binOr,
    t_binAnd,
    t_binEquals,
    t_binNotEquals,
    t_binLThan,
    t_binLThanE,
    t_binGThan,
    t_binGThanE,
    t_binLShift,
    t_binRShift,
    t_binMinus,
    t_binPlus,
    t_binMod,
    t_binMultiply,
    t_binDivide,
    t_singleQuote,
    t_doubleQuote,
    t_lCurly,
    t_rCurly,
    t_lParen,
    t_rParen,
    t_lSquare,
    t_rSquare,
    t_comma,
    t_semicolon

};

char *token_names[] = {
    "Constant",
    "Name",
    "Auto",
    "if",
    "Unary Equals",
    "Unary Minus",
    "Unary Not",
    "-",
    "Binary And",
    "Binary Equals",
    "Binary Not Equals",
    "Binary Less Than",
    "Binary Less Than or Equal",
    "Binary Greater Than",
    "Binary Greater Than or Equal",
    "Binary Left Shift",
    "Binary Right Shift",
    "Binary Minus",
    "Binary Plus",
    "Binary Modulo",
    "Binary Multiply",
    "Binary Divide",
    "Single Quote",
    "Double Quote",
    "Left Curly",
    "Right Curly",
    "Left Paren",
    "Right Paren",
    "Left Square Bracket",
    "Right Square Bracket",
    "Comma",
    "Semicolon"};

enum production
{
    p_program,
    p_definition,
    p_name,
    p_constant,
    p_ival,
    p_statement,
    p_auto,
    p_semicolon,
    p_rvalue,
    p_lvalue,
    p_assign,
    p_unary,
    p_binary,
    p_alpha,
    p_digit,
    p_alphadigit,
    p_lparen,
    p_rparen,
    p_lcurly,
    p_rcurly,
    p_lsquare,
    p_rsquare,
    /*
    * everything from here down is generated by me
    * mostly to do with arbitrary length productions    * 
    */
    p_definitionlist,   // 1 or more definitions (program can't be empty)
    p_ivallist,         // 1 or more ivals, separated by commas
    p_optionalivallist, // 0 or 1 ival lists
    p_optionalconstant, // 0 or 1 constants
    p_namelist,         // 1 or more names, separated by commas
    p_optionalnamelist  // 0 or 1 name lists
};

char *production_names[] = {
    "Program",
    "Definition",
    "Name",
    "Constant",
    "Ival",
    "Statement",
    "Auto",
    ";",
    "rvalue",
    "lvalue",
    "=",
    "unary op",
    "binary op",
    "alpha",
    "digit",
    "alphadigit",
    "(",
    ")",
    "{",
    "}",
    "[",
    "]",
    /*
    * everything from here down is generated by me
    * mostly to do with arbitrary length productions    * 
    */
    "definition List",
    "ival List",
    "Optional ival List",
    "Optional Constant",
    "name List",
    "Optional name List"

};

#define BUF_SIZE 16
char buffer[BUF_SIZE];
int buflen;
enum token currentToken;
char inChar;

struct parseStack *upcomingStack;
struct parseStack *inProgressStack;
struct ASTStack *astStack;

char lookahead_dumb()
{
    long offset = ftell(infile);
    char returnChar = fgetc(infile);
    fseek(infile, offset, SEEK_SET);
    return returnChar;
}

void trimWhitespace()
{
    int whitespace;
    switch (lookahead_dumb())
    {
    case ' ':
    case '\n':
    case '\t':
        whitespace = 1;
        break;
    case '#':
        // recursively handling comments is easy
        // will this come at a cost later?
        while (lookahead_dumb() != '\n')
        {
            fgetc(infile);
        }
        fgetc(infile);
        trimWhitespace();
    default:
        whitespace = 0;
        break;
    }
    while (whitespace)
    {
        fgetc(infile);
        switch (lookahead_dumb())
        {
        case -1:
        case '\0':
        case ' ':
        case '\n':
        case '\t':
            break;
        case '#':
            trimWhitespace();
        default:
            whitespace = 0;
            break;
        }
    }
}

char lookahead()
{
    trimWhitespace();
    return lookahead_dumb();
}

void scan()
{
    buflen = 0;
    // check if we're looking for whitespace - are we?
    trimWhitespace();
    int scanning;
    if (infile != EOF)
    {
        scanning = 1;
    }
    else
    {
        scanning = 0;
    }
    while (scanning)
    {
        inChar = fgetc(infile);
        buffer[buflen++] = inChar;
        buffer[buflen] = '\0';
        if (!strcmp(buffer, "if"))
        {
            currentToken = t_if;
            return;
        }
        else if (!strcmp(buffer, "auto"))
        {
            currentToken = t_auto;
            return;
        }

        switch (inChar)
        {
        case ';':
            currentToken = t_semicolon;
            scanning = 0;
            break;
        case ',':
            currentToken = t_comma;
            scanning = 0;
            break;
        case '(':
            currentToken = t_lParen;
            scanning = 0;
            break;
        case ')':
            currentToken = t_rParen;
            scanning = 0;
            break;
        case '{':
            currentToken = t_lCurly;
            scanning = 0;
            break;
        case '}':
            currentToken = t_rCurly;
            scanning = 0;
            break;
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case '0':
            if (buflen == 1)
            {
                currentToken = t_constant;
            }
            else if (currentToken != t_name)
            {
                printf("Error - unexpected char [%c] in token [%s] \n", inChar, buffer);
            }
            break;
        case '=':
            switch (currentToken)
            {
            case t_binEquals:
                currentToken = t_binEquals;
                scanning = 0;
                break;
            case t_unNot:
                currentToken = t_binNotEquals;
                scanning = 0;
                break;
            case t_binLThan:
                currentToken = t_binLThanE;
                scanning = 0;
                break;
            case t_binGThan:
                currentToken = t_binGThanE;
                scanning = 0;
                break;

            default:
                if (lookahead() != '=')
                {
                    if (buflen > 2)
                    {
                        printf("ERROR: More than 2 [=] in a row!\n");
                        exit(1);
                    }
                    else if (buflen == 2)
                    {
                        currentToken = t_binEquals;
                        scanning = 0;
                    }
                    else
                    {
                        currentToken = t_unEquals;
                        scanning = 0;
                    }
                }
                break;
            }
            break;
        case '|':
            currentToken = t_binOr;
            scanning = 0;
            break;

        case '&':
            currentToken = t_binAnd;
            scanning = 0;
            break;

        case '!':
            currentToken = t_unNot;
            if (lookahead() != '=') // only thing that can extend ! in a token is an =
            {
                scanning = 0;
            }
            break;

        case '<':
            if (buflen == 1) // only 1 '<' so far
            {
                currentToken = t_binLThan;
                if (lookahead() != '=' && lookahead() != '<') // only thing that can extend < in a token is an = or <
                {
                    scanning = 0;
                }
            }
            else // only way to have a < as the second char is to have lShift token
            {
                currentToken = t_binLShift;
                scanning = 0;
            }
            break;

        case '>':
            if (buflen == 1)
            {
                currentToken = t_binGThan;
                if (lookahead() != '=' && lookahead() != '>') // only thing that can extend > in a token is an = or >
                {
                    scanning = 0;
                }
            }
            else // only way to have a > as the second char is to have rShift token
            {
                currentToken = t_binRShift;
                scanning = 0;
            }
            break;

        case '-':
            currentToken = t_binMinus;
            scanning = 0;
            break;

        case '+':
            currentToken = t_binPlus;
            scanning = 0;
            break;

        case '%':
            currentToken = t_binMod;
            scanning = 0;
            break;

        case '*':
            currentToken = t_binMultiply;
            scanning = 0;
            break;

        case '/':
            currentToken = t_binDivide;
            scanning = 0;
            break;

        case -1:
            //case '\0':
            //case ' ':
            //case '\n':
            //case '\t':
            buflen--;
            buffer[buflen] = '\0';
            // don't include whitespace in the buffer
            scanning = 0;
            break;

        default:
            currentToken = t_name;
            break;
        }

        // if there's a paren or bracket coming up
        // terminate the scanning, our token is done
        //printf("LOOKAHEAD IS %c : %d\n", lookahead());
        switch (lookahead_dumb())
        {
        case '(':
        case ')':
        case '{':
        case '}':
        case ' ':
        case '\t':
        case '\n':
        case '\0':
        case ';':
        case ',':
            scanning = 0;
            break;
        }
    }
}

struct PSNode
{
    enum production productionType;
    struct PSNode *next;
    struct PSNode *prev;
};

struct parseStack
{
    struct PSNode *bottom;
    struct PSNode *top;
    int size;
};

void parseStackPush(struct parseStack *it, enum production theProduction)
{
    struct PSNode *newNode = malloc(sizeof(struct PSNode));
    newNode->productionType = theProduction;
    if (it->size == 0)
    {
        it->bottom = newNode;
        it->top = newNode;
    }
    else
    {
        it->top->next = newNode;
        newNode->prev = it->top;
        it->top = newNode;
    }
    it->size++;
}
enum production parseStackPop(struct parseStack *it)
{
    if (it->size == 0)
    {
        printf("Error - tried to pop from empty stack\n");
        exit(1);
    }
    struct PSNode *poppedNode;
    if (it->size == 1)
    {
        poppedNode = it->top;
        it->top = NULL;
        it->bottom = NULL;
    }
    else
    {
        poppedNode = it->top;
        it->top = it->top->prev;
    }
    it->size--;
    enum production retType = poppedNode->productionType;
    free(poppedNode);
    return retType;
}

struct ASTNode
{
    char *value;
    enum token type;
    struct ASTNode *child;
    struct ASTNode *sibling;
};

void ASTNode_InsertSibling(struct ASTNode *it, struct ASTNode *newSibling)
{
    while (it->sibling != NULL)
    {
        it = it->sibling;
    }
    it->sibling = newSibling;
}

void printAST(struct ASTNode *it)
{
    if (it->child != NULL)
    {
        printAST(it->child);
    }
    printf("%s ", it->value);
    if (it->sibling != NULL)
    {
        printAST(it->sibling);
    }
}

struct ASTStackNode
{
    struct ASTNode *data;
    struct ASTStackNode *next;
    struct ASTStackNode *prev;
};

struct ASTStack
{
    struct ASTStackNode *bottom;
    struct ASTStackNode *top;
    int size;
};

void ASTStackPush(enum token t, char *image)
{
    struct ASTNode *newNode = malloc(sizeof(struct ASTNode));
    newNode->value = malloc(strlen(image));
    strcpy(newNode->value, image);
    newNode->type = t;

    struct ASTStackNode *newStackNode = malloc(sizeof(struct ASTStackNode));
    newStackNode->data = newNode;

    if (astStack->size == 0)
    {
        astStack->bottom = newStackNode;
        astStack->top = newStackNode;
    }
    else
    {
        astStack->top->next = newStackNode;
        newStackNode->prev = astStack->top;
        astStack->top = newStackNode;
    }
    astStack->size++;
}

struct ASTNode *ASTStackPop()
{
    if (astStack->size == 0)
    {
        printf("popped from empty stack\n");
        exit(1);
    }
    struct ASTNode *poppedData;
    struct ASTStackNode *poppedNode;
    if (astStack->size == 1)
    {
        poppedNode = astStack->top;
        astStack->top = NULL;
        astStack->bottom = NULL;
    }
    else
    {
        poppedNode = astStack->top;
        astStack->top = astStack->top->prev;
    }
    astStack->size--;
    poppedData = poppedNode->data;
    free(poppedNode);
    return poppedData;
}

void match(enum token t)
{
    scan();
    if (currentToken == t)
    {
        printf("Matched token [%s] with image of [%s]\n", token_names[t], buffer);
        ASTStackPush(t, buffer);
    }
    else
    {
        printf("Error matching - expected token [%s], got [%s] with image of [%s] instead!\n", token_names[t], token_names[currentToken], buffer);
        exit(1);
    }
}

void consume(enum token t)
{
    scan();
    if (currentToken == t)
    {
        printf("Consumed token [%s] with image of [%s]\n", token_names[t], buffer);
    }
    else
    {
        printf("Error consuming - expected token [%s], got [%s] with image of [%s] instead!\n", token_names[t], token_names[currentToken], buffer);
        exit(1);
    }
}

void stackParse()
{
    upcomingStack = malloc(sizeof(struct parseStack));
    inProgressStack = malloc(sizeof(struct parseStack));
    astStack = malloc(sizeof(struct ASTStack));
    printf("Entered stackparse routine\n");
    parseStackPush(upcomingStack, p_program);
    while (upcomingStack->size > 0)
    {
        // spin so this goes at a sane pace
        // there *will* be accidental loops, need to read the output
        for (int i = 0; i < 0xffffff; i++)
        {
        }
        enum production currentProduction = parseStackPop(upcomingStack);
        printf("Parsing production [%s]\n", production_names[currentProduction]);
        switch (currentProduction)
        {
        case p_program:
            parseStackPush(upcomingStack, p_definitionlist);
            // need to include EOF token or not?
            break;
        case p_definitionlist:
            if (isalpha(lookahead())) // we have at least 1 more definition to go
            {
                parseStackPush(upcomingStack, p_definitionlist);
                parseStackPush(upcomingStack, p_definition);
            }
            // if we have a definition list and don't see something in FIRST(name) (alpha char) we are done
            break;
        case p_definition:
            if (isalpha(lookahead()))
            {
                match(t_name);
                char l = lookahead();
                if (isalpha(l) || isdigit(l) || l == '[')
                {
                    // name {[{constant01}]}01 {ival {, ival}0}01;
                    parseStackPush(upcomingStack, p_semicolon);
                    parseStackPush(upcomingStack, p_optionalivallist);
                    parseStackPush(upcomingStack, p_ival);
                    if (l == '[')
                    {
                        parseStackPush(upcomingStack, p_rsquare);
                        parseStackPush(upcomingStack, p_optionalconstant);
                        parseStackPush(upcomingStack, p_lsquare);
                    }
                }
                else if (l == '(')
                {
                    // name ( {name {, name}0}01 ) statement
                    parseStackPush(upcomingStack, p_statement);
                    parseStackPush(upcomingStack, p_rparen);
                    parseStackPush(upcomingStack, p_optionalnamelist);
                    parseStackPush(upcomingStack, p_lparen);
                }
                else if (l == ';') // just a name declaration
                {
                    parseStackPush(upcomingStack, p_semicolon);
                }
                else
                {
                    printf("Error - expected '[', '(', or ival after name in definition\n");
                    exit(1);
                }
            }
            break;
        case p_ival:
            if (isalpha(lookahead()))
            {
                parseStackPush(upcomingStack, p_name);
            }
            else if (isdigit(lookahead()))
            {
                parseStackPush(upcomingStack, p_constant);
            }
            else
            {
                printf("Error parsing ival - expected constant or name!\n");
                exit(1);
            }
            break;
        case p_constant:
            match(t_constant);
            break;
        case p_name:
            match(t_name);
            break;
        case p_lparen:
            match(t_lParen);
            break;
        case p_rparen:
            match(t_rParen);
            break;
        case p_namelist:
            if (lookahead() == ',')
            {
                consume(t_comma);
            }
            if (isalpha(lookahead()))
            {
                parseStackPush(upcomingStack, p_namelist);
                parseStackPush(upcomingStack, p_name);
            }
            break;
        case p_optionalnamelist:
            if (isalpha(lookahead()))
            {
                parseStackPush(upcomingStack, p_namelist);
            }
            else
            {
                printf("Optional name List not present\n");
            }
            break;
        case p_optionalivallist:
            if (isalpha(lookahead()) || isdigit(lookahead()))
            {
                parseStackPush(upcomingStack, p_ivallist);
            }
            else
            {
                printf("Optional ival List not present\n");
            }
            break;
        case p_optionalconstant:
            if (isdigit(lookahead()))
            {
                parseStackPush(upcomingStack, p_constant);
            }
            else
            {
                printf("Optional Constant not present\n");
            }
            break;
        case p_semicolon:
            consume(t_semicolon);
        }

        // keep track of what's being worked on so we can shift and reduce
        parseStackPush(inProgressStack, currentProduction);
        switch (inProgressStack->bottom->productionType)
        {
            // case for all production types
            // whenever we see something *not* in that production
            // decide somehow to reduce and how to build the tree
        default:
            break;
        }
    }
}

int main(int argc, char **argv)
{
    printf("%s\n", argv[1]);
    infile = fopen(argv[1], "rb");
    stackParse();
    printf("\n\nDONE PARSING - HERE IS THE STATE OF THE STACK\n");
    struct ASTStackNode *theNode = astStack->top;
    while (theNode != NULL)
    {
        struct ASTNode* data = theNode->data;
        printf("[%16s] %s\n", token_names[data->type], data->value);
        theNode = theNode->prev;
    }

    /*while (lookahead() != EOF)
    {
        scan();
        printf("Scanned %s with token of %s\n", &buffer, token_names[currentToken]);
    }*/
}