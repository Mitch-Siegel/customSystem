#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

FILE *infile;

enum token
{
    t_constant,
    t_name,
    t_auto,
    t_extrn,
    t_case,
    t_if,
    t_while,
    t_switch,
    t_goto,
    t_return,
    t_unEquals,
    t_unMinus,
    t_unNot,
    t_binOr,
    t_binAnd,
    t_binEquals,
    t_binNotEquals,
    t_binLThan,
    t_binLThanE,
    t_binGThan,
    t_binGThanE,
    t_binLShift,
    t_binRShift,
    t_binMinus,
    t_binPlus,
    t_binMod,
    t_binMultiply,
    t_binDivide,
    t_singleQuote,
    t_doubleQuote,
    t_lCurly,
    t_rCurly,
    t_lParen,
    t_rParen,
    t_lSquare,
    t_rSquare,
    t_comma,
    t_semicolon

};

char *token_names[] = {
    "Constant",
    "Name",
    "auto",
    "extrn",
    "case",
    "if",
    "while",
    "switch",
    "goto",
    "return",
    "Unary Equals",
    "Unary Minus",
    "Unary Not",
    "-",
    "Binary And",
    "Binary Equals",
    "Binary Not Equals",
    "Binary Less Than",
    "Binary Less Than or Equal",
    "Binary Greater Than",
    "Binary Greater Than or Equal",
    "Binary Left Shift",
    "Binary Right Shift",
    "Binary Minus",
    "Binary Plus",
    "Binary Modulo",
    "Binary Multiply",
    "Binary Divide",
    "Single Quote",
    "Double Quote",
    "Left Curly",
    "Right Curly",
    "Left Paren",
    "Right Paren",
    "Left Square Bracket",
    "Right Square Bracket",
    "Comma",
    "Semicolon"};

enum production
{
    p_program,
    p_definition,
    p_name,
    p_constant,
    p_ival,
    p_statement,
    p_auto,
    p_semicolon,
    p_colon,
    p_rvalue,
    p_lvalue,
    p_assign,
    p_unary,
    p_binary,
    p_alpha,
    p_digit,
    p_alphadigit,
    p_lparen,
    p_rparen,
    p_lcurly,
    p_rcurly,
    p_lsquare,
    p_rsquare,
    p_extrn,
    p_case,
    p_if,
    p_while,
    p_switch,
    p_goto,
    p_return,
    /*
    * everything from here down is generated by me
    * mostly to do with arbitrary length productions    * 
    */
    p_statementlist,    // 0 or more statements
    p_definitionlist,   // 1 or more definitions (program can't be empty)
    p_ivallist,         // 1 or more ivals, separated by commas
    p_optionalivallist, // 0 or 1 ival lists
    p_optionalconstant, // 0 or 1 constants
    p_namelist,         // 1 or more names, separated by commas
    p_optionalnamelist, // 0 or 1 name lists
    p_optionalrvalue    // 0 or 1 rvalues

};

char *production_names[] = {
    "Program",
    "Definition",
    "Name",
    "Constant",
    "Ival",
    "Statement",
    "Auto",
    ";",
    ":",
    "rvalue",
    "lvalue",
    "=",
    "unary op",
    "binary op",
    "alpha",
    "digit",
    "alphadigit",
    "(",
    ")",
    "{",
    "}",
    "[",
    "]",
    "extrn",
    "case",
    "if",
    "while",
    "switch",
    "goto",
    "return",
    /*
    * everything from here down is generated by me
    * mostly to do with arbitrary length productions    * 
    */
    "statement list",
    "definition List",
    "ival List",
    "Optional ival List",
    "Optional Constant",
    "name List",
    "Optional name List",
    "Optional rvalue"

};

#define BUF_SIZE 16
char buffer[BUF_SIZE];
int buflen;
enum token currentToken;
char inChar;

struct parseStack *upcomingStack;
struct parseStack *inProgressStack;
struct ASTStack *astStack;

struct PSNode
{
    enum production productionType;
    struct PSNode *next;
    struct PSNode *prev;
};

struct parseStack
{
    struct PSNode *bottom;
    struct PSNode *top;
    int size;
};

void parseStackPush(struct parseStack *it, enum production theProduction)
{
    struct PSNode *newNode = malloc(sizeof(struct PSNode));
    newNode->productionType = theProduction;
    if (it->size == 0)
    {
        it->bottom = newNode;
        it->top = newNode;
    }
    else
    {
        it->top->next = newNode;
        newNode->prev = it->top;
        it->top = newNode;
    }
    it->size++;
}

enum production parseStackPop(struct parseStack *it)
{
    if (it->size == 0)
    {
        printf("Error - tried to pop from empty stack\n");
        exit(1);
    }
    struct PSNode *poppedNode;
    if (it->size == 1)
    {
        poppedNode = it->top;
        it->top = NULL;
        it->bottom = NULL;
    }
    else
    {
        poppedNode = it->top;
        it->top = it->top->prev;
    }
    it->size--;
    enum production retType = poppedNode->productionType;
    free(poppedNode);
    return retType;
}

struct ASTNode
{
    char *value;
    enum token type;
    struct ASTNode *child;
    struct ASTNode *sibling;
};

void ASTNode_InsertSibling(struct ASTNode *it, struct ASTNode *newSibling)
{
    while (it->sibling != NULL)
    {
        it = it->sibling;
    }
    it->sibling = newSibling;
}

void printAST(struct ASTNode *it)
{
    if (it->child != NULL)
    {
        printAST(it->child);
    }
    printf("%s ", it->value);
    if (it->sibling != NULL)
    {
        printAST(it->sibling);
    }
}

struct ASTStackNode
{
    struct ASTNode *data;
    struct ASTStackNode *next;
    struct ASTStackNode *prev;
};

struct ASTStack
{
    struct ASTStackNode *bottom;
    struct ASTStackNode *top;
    int size;
};

void ASTStackPush(enum token t, char *image)
{
    struct ASTNode *newNode = malloc(sizeof(struct ASTNode));
    newNode->value = malloc(strlen(image));
    strcpy(newNode->value, image);
    newNode->type = t;

    struct ASTStackNode *newStackNode = malloc(sizeof(struct ASTStackNode));
    newStackNode->data = newNode;

    if (astStack->size == 0)
    {
        astStack->bottom = newStackNode;
        astStack->top = newStackNode;
    }
    else
    {
        astStack->top->next = newStackNode;
        newStackNode->prev = astStack->top;
        astStack->top = newStackNode;
    }
    astStack->size++;
}

struct ASTNode *ASTStackPop()
{
    if (astStack->size == 0)
    {
        printf("popped from empty stack\n");
        exit(1);
    }
    struct ASTNode *poppedData;
    struct ASTStackNode *poppedNode;
    if (astStack->size == 1)
    {
        poppedNode = astStack->top;
        astStack->top = NULL;
        astStack->bottom = NULL;
    }
    else
    {
        poppedNode = astStack->top;
        astStack->top = astStack->top->prev;
    }
    astStack->size--;
    poppedData = poppedNode->data;
    free(poppedNode);
    return poppedData;
}

void error()
{
    struct ASTStackNode *theNode = astStack->top;
    while (theNode != NULL)
    {
        struct ASTNode *data = theNode->data;
        printf("[%16s] %s\n", token_names[data->type], data->value);
        theNode = theNode->prev;
    }
    exit(1);
}

char lookahead_dumb()
{
    long offset = ftell(infile);
    char returnChar = fgetc(infile);
    fseek(infile, offset, SEEK_SET);
    return returnChar;
}

void trimWhitespace()
{
    int whitespace;
    switch (lookahead_dumb())
    {
    case ' ':
    case '\n':
    case '\t':
        whitespace = 1;
        break;
    case '#':
        // recursively handling comments is easy
        // will this come at a cost later?
        while (lookahead_dumb() != '\n')
        {
            fgetc(infile);
        }
        fgetc(infile);
        trimWhitespace();
    default:
        whitespace = 0;
        break;
    }
    while (whitespace)
    {
        fgetc(infile);
        switch (lookahead_dumb())
        {
        case -1:
        case '\0':
        case ' ':
        case '\n':
        case '\t':
            break;
        case '#':
            trimWhitespace();
        default:
            whitespace = 0;
            break;
        }
    }
}

char lookahead()
{
    trimWhitespace();
    return lookahead_dumb();
}

void scan()
{
    buflen = 0;
    // check if we're looking for whitespace - are we?
    trimWhitespace();
    int scanning;
    if (infile != EOF)
    {
        scanning = 1;
    }
    else
    {
        scanning = 0;
    }
    while (scanning)
    {
        inChar = fgetc(infile);
        buffer[buflen++] = inChar;
        buffer[buflen] = '\0';
        if (!strcmp(buffer, "if"))
        {
            currentToken = t_if;
            return;
        }
        else if (!strcmp(buffer, "auto"))
        {
            currentToken = t_auto;
            return;
        }
        else if (!strcmp(buffer, "extrn"))
        {
            currentToken = t_extrn;
            return;
        }
        else if (!strcmp(buffer, "case"))
        {
            currentToken = t_case;
            return;
        }
        else if (!strcmp(buffer, "if"))
        {
            currentToken = t_if;
            return;
        }
        else if (!strcmp(buffer, "while"))
        {
            currentToken = t_while;
            return;
        }
        else if (!strcmp(buffer, "switch"))
        {
            currentToken = t_switch;
            return;
        }
        else if (!strcmp(buffer, "goto"))
        {
            currentToken = t_goto;
            return;
        }
        else if (!strcmp(buffer, "return"))
        {
            currentToken = t_return;
            return;
        }

        switch (inChar)
        {
        case ';':
            currentToken = t_semicolon;
            scanning = 0;
            break;
        case ',':
            currentToken = t_comma;
            scanning = 0;
            break;
        case '(':
            currentToken = t_lParen;
            scanning = 0;
            break;
        case ')':
            currentToken = t_rParen;
            scanning = 0;
            break;
        case '{':
            currentToken = t_lCurly;
            scanning = 0;
            break;
        case '}':
            currentToken = t_rCurly;
            scanning = 0;
            break;
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case '0':
            if (buflen == 1)
            {
                currentToken = t_constant;
            }
            else if (currentToken != t_name)
            {
                printf("Error - unexpected char [%c] in token [%s] \n", inChar, buffer);
            }
            break;
        case '=':
            switch (currentToken)
            {
            case t_binEquals:
                currentToken = t_binEquals;
                scanning = 0;
                break;
            case t_unNot:
                currentToken = t_binNotEquals;
                scanning = 0;
                break;
            case t_binLThan:
                currentToken = t_binLThanE;
                scanning = 0;
                break;
            case t_binGThan:
                currentToken = t_binGThanE;
                scanning = 0;
                break;

            default:
                if (lookahead() != '=')
                {
                    if (buflen > 2)
                    {
                        printf("ERROR: More than 2 [=] in a row!\n");
                        error();
                    }
                    else if (buflen == 2)
                    {
                        currentToken = t_binEquals;
                        scanning = 0;
                    }
                    else
                    {
                        currentToken = t_unEquals;
                        scanning = 0;
                    }
                }
                break;
            }
            break;
        case '|':
            currentToken = t_binOr;
            scanning = 0;
            break;

        case '&':
            currentToken = t_binAnd;
            scanning = 0;
            break;

        case '!':
            currentToken = t_unNot;
            if (lookahead() != '=') // only thing that can extend ! in a token is an =
            {
                scanning = 0;
            }
            break;

        case '<':
            if (buflen == 1) // only 1 '<' so far
            {
                currentToken = t_binLThan;
                if (lookahead() != '=' && lookahead() != '<') // only thing that can extend < in a token is an = or <
                {
                    scanning = 0;
                }
            }
            else // only way to have a < as the second char is to have lShift token
            {
                currentToken = t_binLShift;
                scanning = 0;
            }
            break;

        case '>':
            if (buflen == 1)
            {
                currentToken = t_binGThan;
                if (lookahead() != '=' && lookahead() != '>') // only thing that can extend > in a token is an = or >
                {
                    scanning = 0;
                }
            }
            else // only way to have a > as the second char is to have rShift token
            {
                currentToken = t_binRShift;
                scanning = 0;
            }
            break;

        case '-':
            currentToken = t_binMinus;
            scanning = 0;
            break;

        case '+':
            currentToken = t_binPlus;
            scanning = 0;
            break;

        case '%':
            currentToken = t_binMod;
            scanning = 0;
            break;

        case '*':
            currentToken = t_binMultiply;
            scanning = 0;
            break;

        case '/':
            currentToken = t_binDivide;
            scanning = 0;
            break;

        case -1:
            //case '\0':
            //case ' ':
            //case '\n':
            //case '\t':
            buflen--;
            buffer[buflen] = '\0';
            // don't include whitespace in the buffer
            scanning = 0;
            break;

        default:
            currentToken = t_name;
            break;
        }

        // if there's a paren or bracket coming up
        // terminate the scanning, our token is done
        //printf("LOOKAHEAD IS %c : %d\n", lookahead());
        switch (lookahead_dumb())
        {
        case '(':
        case ')':
        case '{':
        case '}':
        case ' ':
        case '\t':
        case '\n':
        case '\0':
        case ',':
        case ':':
        case ';':
            scanning = 0;
            break;
        }
    }
}

char *lookaheadToken() // look ahead at the entire next token, populate the buffer
{
    trimWhitespace();

    long offset = ftell(infile);
    scan();                          // simply use the scan function to get exactly what the next token is, no fuss
    fseek(infile, offset, SEEK_SET); // then seek backwards as if we never scanned
    printf("returning token buffer of %s\n", buffer);
    return buffer;
}

void match(enum token t)
{

    scan();
    if (currentToken == t)
    {
        printf("Matched token [%s] with image of [%s]\n", token_names[t], buffer);
        ASTStackPush(t, buffer);
    }
    else
    {
        printf("Error matching - expected token [%s], got [%s] with image of [%s] instead!\n", token_names[t], token_names[currentToken], buffer);
        error();
    }
}

void consume(enum token t)
{
    scan();
    if (currentToken == t)
    {
        printf("Consumed token [%s] with image of [%s]\n", token_names[t], buffer);
    }
    else
    {
        printf("Error consuming - expected token [%s], got [%s] with image of [%s] instead!\n", token_names[t], token_names[currentToken], buffer);
        error();
    }
}

void stackParse()
{
    upcomingStack = malloc(sizeof(struct parseStack));
    inProgressStack = malloc(sizeof(struct parseStack));
    astStack = malloc(sizeof(struct ASTStack));
    printf("Entered stackparse routine\n");
    parseStackPush(upcomingStack, p_program);
    while (upcomingStack->size > 0)
    {
        // spin so this goes at a sane pace
        // there *will* be accidental loops, need to read the output
        for (int i = 0; i < 0xffffff; i++)
        {
        }
        enum production currentProduction = parseStackPop(upcomingStack);
        printf("Parsing production [%s]\n", production_names[currentProduction]);
        switch (currentProduction)
        {
        case p_program:
            parseStackPush(upcomingStack, p_definitionlist);
            // need to include EOF token or not?
            break;

        case p_definitionlist:
            if (lookahead() == ',')
            {
                consume(t_comma);
            }
            if (isalpha(lookahead())) // we have at least 1 more definition to go
            {
                parseStackPush(upcomingStack, p_definitionlist);
                parseStackPush(upcomingStack, p_definition);
            }
            // if we have a definition list and don't see something in FIRST(name) (alpha char) we are done
            break;

        case p_definition:
            if (isalpha(lookahead()))
            {
                match(t_name);
                char l = lookahead();
                if (isalpha(l) || isdigit(l) || l == '[')
                {
                    // name {[{constant01}]}01 {ival {, ival}0}01;
                    parseStackPush(upcomingStack, p_semicolon);
                    parseStackPush(upcomingStack, p_optionalivallist);
                    parseStackPush(upcomingStack, p_ival);
                    if (l == '[')
                    {
                        parseStackPush(upcomingStack, p_rsquare);
                        parseStackPush(upcomingStack, p_optionalconstant);
                        parseStackPush(upcomingStack, p_lsquare);
                    }
                }
                else if (l == '(')
                {
                    // name ( {name {, name}0}01 ) statement
                    parseStackPush(upcomingStack, p_statement);
                    parseStackPush(upcomingStack, p_rparen);
                    parseStackPush(upcomingStack, p_optionalnamelist);
                    parseStackPush(upcomingStack, p_lparen);
                }
                else if (l == ';') // just a name declaration
                {
                    parseStackPush(upcomingStack, p_semicolon);
                }
                else
                {
                    printf("Error - expected '[', '(', or ival after name in definition\n");
                    error();
                }
            }
            else
            {
                printf("Error parsing definition - expected name\n");
                error();
            }
            break;

        case p_ival:
            if (isalpha(lookahead()))
            {
                parseStackPush(upcomingStack, p_name);
            }
            else if (isdigit(lookahead()))
            {
                parseStackPush(upcomingStack, p_constant);
            }
            else
            {
                printf("Error parsing ival - expected constant or name!\n");
                error();
            }
            break;

        case p_statementlist:
            // naive?
            // sure it'll allow unwanted chars in, but the errors will be at match time so better verbosity?
            // is there any other disadvantage to blindly accepting anything here?
            if (lookahead() != '}')
            {
                parseStackPush(upcomingStack, p_statementlist);
                parseStackPush(upcomingStack, p_statement);
            }

        case p_statement:
            char *nextToken = lookaheadToken();
            if (!strcmp(nextToken, "auto")) // auto name {constant}01 {, name {constant}01}0 ;  statement
            {
                // {, name {constant}01}0 PART IS UNHANDLED
                parseStackPush(upcomingStack, p_statement);
                parseStackPush(upcomingStack, p_semicolon);
                parseStackPush(upcomingStack, p_optionalconstant);
                parseStackPush(upcomingStack, p_name);
                parseStackPush(upcomingStack, p_auto);
            }
            else if (!strcmp(nextToken, "extrn")) // extrn name {, name}0 ; statement
            {
                parseStackPush(upcomingStack, p_statement);
                parseStackPush(upcomingStack, p_semicolon);
                parseStackPush(upcomingStack, p_optionalnamelist);
                parseStackPush(upcomingStack, p_name);
                parseStackPush(upcomingStack, p_extrn);
            }
            else if (!strcmp(nextToken, "case"))
            {
                parseStackPush(upcomingStack, p_statement);
                parseStackPush(upcomingStack, p_colon);
                parseStackPush(upcomingStack, p_name);
                parseStackPush(upcomingStack, p_case);
            }
            else if (!strcmp(nextToken, "if")) // if ( rvalue ) statement {else statement}01
            {
                parseStackPush(upcomingStack, p_statement);
                parseStackPush(upcomingStack, p_rparen);
                parseStackPush(upcomingStack, p_rvalue);
                parseStackPush(upcomingStack, p_lparen);
                parseStackPush(upcomingStack, p_if);
            }
            else if (!strcmp(nextToken, "while")) // whit_autoe ( rvalue ) statement
            {
                parseStackPush(upcomingStack, p_statement);
                parseStackPush(upcomingStack, p_rparen);
                parseStackPush(upcomingStack, p_rvalue);
                parseStackPush(upcomingStack, p_lparen);
                parseStackPush(upcomingStack, p_while);
            }
            else if (!strcmp(nextToken, "switch"))
            {
                parseStackPush(upcomingStack, p_statement);
                parseStackPush(upcomingStack, p_rvalue);
                parseStackPush(upcomingStack, p_switch);
            }
            else if (!strcmp(nextToken, "goto"))
            {

                parseStackPush(upcomingStack, p_semicolon);
                parseStackPush(upcomingStack, p_rvalue);
                parseStackPush(upcomingStack, p_goto);
            }
            else if (!strcmp(nextToken, "return"))
            {
                parseStackPush(upcomingStack, p_optionalrvalue);
                parseStackPush(upcomingStack, p_return);
            }
            else
            {
                if (isalpha(lookahead()))
                {
                    match(t_name);
                    parseStackPush(upcomingStack, p_statement);
                    parseStackPush(upcomingStack, p_colon);
                }
                else if (lookahead() == '{')
                {
                    // { {statement}0 }
                    // NOTE - current production DOES NOT support optional statements ({}), there MUST be something in between the curly braces
                    parseStackPush(upcomingStack, p_rcurly);
                    parseStackPush(upcomingStack, p_statementlist);
                    parseStackPush(upcomingStack, p_lcurly);
                }
                else
                {
                    printf("Error parsing statement - could be due to unhandled [statement::={rvalue}01;] production\n");
                    error();
                }
            }
            break;

        case p_auto:
            match(t_auto);
            break;

        case p_extrn:
            match(t_extrn);
            break;

        case p_case:
            match(t_case);
            break;

        case p_if:
            match(t_if);
            break;

        case p_while:
            match(t_while);
            break;

        case p_switch:
            match(t_switch);
            break;

        case p_goto:
            match(t_goto);
            break;

        case p_return:
            match(t_return);
            break;

        case p_name:
            match(t_name);
            break;

        case p_lparen:
            consume(t_lParen);
            break;

        case p_rparen:
            consume(t_rParen);
            break;

        case p_lcurly:
            consume(t_lCurly);
            break;

        case p_rcurly:
            consume(t_rCurly);
            break;

        case p_namelist:
            if (lookahead() == ',')
            {
                consume(t_comma);
            }
            if (isalpha(lookahead()))
            {
                parseStackPush(upcomingStack, p_namelist);
                parseStackPush(upcomingStack, p_name);
            }
            break;
        case p_optionalnamelist:
            if (isalpha(lookahead()))
            {
                parseStackPush(upcomingStack, p_namelist);
            }
            else
            {
                printf("Optional name List not present\n");
            }
            break;
        case p_optionalivallist:
            if (isalpha(lookahead()) || isdigit(lookahead()))
            {
                parseStackPush(upcomingStack, p_ivallist);
            }
            else
            {
                printf("Optional ival List not present\n");
            }
            break;
        case p_optionalconstant:
            if (isdigit(lookahead()))
            {
                parseStackPush(upcomingStack, p_constant);
            }
            else
            {
                printf("Optional Constant not present\n");
            }
            break;
        case p_semicolon:
            consume(t_semicolon);
        }

        /*
        // keep track of what's being worked on so we can shift and reduce
        parseStackPush(inProgressStack, currentProduction);
        switch (inProgressStack->bottom->productionType)
        {
            // case for all production types
            // whenever we see something *not* in that production
            // decide somehow to reduce and how to build the tree
        default:
            break;
        }
        */
    }
}

int main(int argc, char **argv)
{
    printf("%s\n", argv[1]);
    infile = fopen(argv[1], "rb");
    stackParse();
    printf("\n\nDONE PARSING - HERE IS THE STATE OF THE STACK\n");
    struct ASTStackNode *theNode = astStack->top;
    while (theNode != NULL)
    {
        struct ASTNode *data = theNode->data;
        printf("[%16s] %s\n", token_names[data->type], data->value);
        theNode = theNode->prev;
    }

    /*while (lookahead() != EOF)
    {
        scan();
        printf("Scanned %s with token of %s\n", &buffer, token_names[currentToken]);
    }*/
}